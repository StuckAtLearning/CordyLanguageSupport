
export function getHovers(): Map<string, string> {
    return new Map([
        ["print", "```\nprint(any, ...)\n```\n\nPrints each argument, space seperated and with a single `\n` suffix, to standard output. Non-string types will have `str()` called on them before printing.\n\nWhen called with no arguments, prints a single `\n` character.\n\nReturns `nil`\n"],
        ["bool", "```\nbool(x: any) -> bool\n```\n\nReturns the argument as a boolean. `nil`, `0`, `false`, `''`, and empty collections, will return `false`, everything else will return `true`.\n\nThe keyword `bool` can also be used in an `is` expression, to check if a value is of the type `bool`.\n"],
        ["int", "```\nint(x: any) -> int\n```\n\nReturns the argument as an integer. `nil` and `false` evaluate to `0`, where strings will be parsed as an integer or raise an error.\n\nThe keyword `int` can also be used in an `is` expression, to check if a value is of the type `int`.\n\n**Example**\n\n```\n>>> int('3')\n3\n>>> 3 is int\ntrue\n>>> '3' is int\nfalse\n```\n"],
        ["str", "```\nstr(x: any) -> str\n```\n\nReturns the argument as a string. See also `repr`.\n\nThe keyword `str` can also be used in an `is` expression, to check if a value is of the type `str`.\n\n"],
        ["list", "```\nlist(...) -> list\n```\n\nPossible signatures:\n\n- `list() -> list`\n- `<T> list(it: iterable<T>) -> list<T>`\n- `<T> list(T, ...) -> list<T>`\n\nWith no arguments, creates an empty list, the same as `[]`. With one argument, treats the argument as an iterable and copies each element into a new list. With more than one argument, collects each argument into a list.\n\nThe keyword `list` can also be used in an `is` expression, to check if a value is of the type `list`.\n\n**Example**\n\n```\n>>> list()\n[]\n>>> list('hello')\n['h', 'e', 'l', 'l', 'o']\n>>> list(1, 2, 3, 4)\n[1, 2, 3, 4]\n```\n"],
        ["set", "```\nset(...) -> set\n```\n\nPossible signatures:\n\n- `set() -> set`\n- `<T> set(it: iterable<T>) -> set<T>`\n- `<T> set(T, ...) -> set<T>`\n\nWith no arguments, creates an empty set. With one argument, treats the argument as an iterable and copies each element into a new set. With more than one argument, collects each argument into a set.\n\nThe keyword `set` can also be used in an `is` expression, to check if a value is of the type `set`.\n\n**Example**\n\n```\n>>> set()\n{}\n>>> set('blahaj')\n{'b', 'l', 'h', 'a', 'j'}\n>>> set(1, 2, 3, 4)\n{1, 2, 3, 4}\n```\n"],
        ["dict", "```\ndict(...) -> dict\n```\n\nPossible signatures:\n\n- `dict() -> dict`\n- `<K, V> dict(it: iterable<vector<K, V>>) -> dict<K, V>`\n- `<K, V> dict(vector<K, V>, ...) -> dict<K, V>`\n\nWith no arguments, creates an empty dictionary. With one argument, treats the argument as an iterable of key-value pairs and collects it into a new dictionary. With more than one argument, treats each argument as a key-value pair and collects each argument into a dictionary.\n\nThe keyword `dict` can also be used in an `is` expression, to check if a value is of the type `dict`.\n"],
        ["heap", "```\nheap(...) -> heap\n```\n\nPossible signatures:\n\n- `heap() -> heap`\n- `<T> heap(it: iterable<T>) -> heap<T>`\n- `<T> heap(T, ...) -> heap<T>`\n\nWith no arguments, creates an empty heap. With one argument, treats the argument as an iterable and copies each element into a new heap, maintaining the heap invariant. With more than one argument, collects each argument into a heap, maintaining the heap invariant.\n\n**Note:** Heaps of different types behavior is unspecified, as different types will compare equal and can have any internal ordering.\n\nThe keyword `heap` can also be used in an `is` expression, to check if a value is of the type `heap`.\n"],
        ["vector", "```\nvector(...) -> vector\n```\n\nPossible signatures:\n\n- `vector() -> vector`\n- `<T> vector(it: iterable<T>) -> vector<T>`\n- `<T> vector(T, ...) -> vector<T>`\n\nWith no arguments, creates an empty vector. With one argument, treats the argument as an iterable and copies each element into a new vector. With more than one argument, collects each argument into a vector.\n\nThe keyword `vector` can also be used in an `is` expression, to check if a value is of the type `vector`.\n"],
        ["function", "```\nfunction\n```\n\nThe keyword `function` can be used in an `is` expression, to check if a value is of the type `function`.\n\n```\n>>> fn() {} is function\ntrue\n>>> print is function\ntrue\n>>> 'hello' is function\nfalse\n```\n"],
        ["repr", "```\nrepr(x: any) -> str\n```\n\nReturns the full representation of `x`, as a string. Strings are wrapped in single quotes, unlike `str`, although is functionally similar in other respects.\n\n```\n>>> repr('hello')\n'hello'\n```\n"],
        ["len", "```\nlen(x: iterable) -> int\n```\n\nReturns the length of `x`. For strings, this returns the number of Unicode Scalar Values. It is `O(1)` except for `str`, which is `O(n)`.\n"],
        ["range", "```\nrange(...) -> list<int>\n```\n\nPossible signatures:\n\n- `range(stop: int) -> list<int>`\n- `range(start: int, stop: int) -> list<int>`\n- `range(start: int, stop: int, step: int) -> list<int>`\n\nReturns a list of `int`, from `start` inclusive, to `stop` exclusive, counting by `step`. The default value of `start` is `0`, and `step` is 1 when not provided.\n\n**Note:** When used in `for x in range()` loop, this function elides creating a `list<int>` and instead lazily populates `x`.\n"],
        ["enumerate", "```\n<T> enumerate(x: iterable<A>) -> list<vector<int, A>>\n```\n\nReturns a `list` of pairs, of index and value of each element in the iterable `x`.\n\n**Example**\n\n```\n>>> enumerate('hey')\n[(0, 'h'), (1, 'e'), (2, 'y')]\n```\n"],
        ["sum", "```\nsum(...) -> int\n```\n\nPossible signatures:\n\n- `sum(it: iterable<int>) -> int`\n- `sum(int, ...) -> int`\n\nWith one argument, returns the sum of each value in the iterable. With more than one argument, returns the sum of all the arguments. Raises an error when invoked with no arguments.\n"],
        ["min", "```\nmin(...) -> int\n```\n\nPossible signatures:\n\n- `min(it: iterable<int>) -> int`\n- `min(int, ...) -> int`\n\nWith one argument, returns the minimum of each value in the iterable. With more than one argument, returns the minimum of all the arguments. Raises an error when invoked with no arguments.\n"],
        ["max", "```\nmax(...) -> int\n```\n\nPossible signatures:\n\n- `max(it: iterable<int>) -> int`\n- `max(int, ...) -> int`\n\nWith one argument, returns the maximum of each value in the iterable. With more than one argument, returns the maximum of all the arguments. Raises an error when invoked with no arguments.\n"],
        ["map", "```\n<A, B> map(f: fn(A) -> B, it: iterable<A>) -> list<B>\n```\n\nApplies the function `f` to each value in the iterable `it`, and returns the list of each result.\n\n**Example**\n\n```\n>>> [1, 3, 5] . map(+1)\n[2, 4, 6]\n```\n"],
        ["filter", "```\n<A> filter(f: fn(A) -> any, it: iterable<A>) -> list<A>\n```\n\nApplies the function `f` to each value in the iterable `it`, and retains that value if it returns a truthy value. Returns a list of all elements which returned a truthy value.\n\n**Example**\n\n```\n>>> [-2, 4, -4, 2] . filter(>0)\n[4, 2]\n```\n"],
        ["flat_map", "```\n<A, B> flat_map(f: fn(A) -> iterable<B>, it: iterable<A>) -> list<B>\n```\n\nApplies the function `f` to each element in `it`, and then concatenates the results. This is equivalent to `. map(f) . concat`.\n\n**Example**\n\n```\n>>> [1, 2, 3, 4] . flat_map(fn(i) -> range(i))\n[0, 0, 1, 0, 1, 2, 0, 1, 2, 3]\n```\n"],
        ["concat", "```\n<A> concat(it: iterable<iterable<A>>) -> list<A>\n```\n\nConcatenates the iterables in the input into one list. This is equivalent to `flat_map(fn(x) -> x)`, but should be preferred over that due to performance.\n\n**Example**\n\n```\n>>> [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . concat\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n"],
        ["zip", "```\n<A> zip(...) -> list<A>\n```\n\nPossible signatures:\n\n- `<A> zip(it: iterable<iterable<A>>) -> list<A>`\n- `<A> zip(iterable<A>, ...) -> list<A>`\n\nWhen invoked with a single argument, treats the argument as an iterable and each element as an individual argument. Then, iterates each iterable in parallel, returning a list of vectors until the shortest iterable is exhausted.\n\n**Example**\n\n```\n>>> zip([1, 2, 3], [10, 20, 30])\n[(1, 10), (2, 20), (3, 30)]\n>>> zip(['hello', 'the', 'world'])\n[('h', 't', 'w'), ('e', 'h', 'o'), ('e', 'e', 'r')]\n```\n"],
        ["reduce", "```\n<A> reduce(f: fn(A, A) -> A, it: iterable<A>) -> A\n```\n\nReduces an iterable to a single value by successively applying `f` on the first two elements in the iterable, until only one remains. Raises an error if the argument was an empty iterable\n\n**Example**\n\n```\n>>> [1, 3, 5, 7] . reduce(+)\n16\n>>> ['hello', 'the', 'world'] . reduce(fn(a, b) -> a + ' ' + b)\n'hello the world'\n```\n"],
        ["sorted", "```\n<A> sorted(it: iterable<A>) -> list<A>\n```\n\nReturns a list of the elements in `it`, sorted in ascending order. Note that if `it` contains multiple different types the returned order is unspecified as different types will compare as equal.\n\n**Example**\n\n```\n>>> [1, 5, 3, 2, 4] . sorted\n[1, 2, 3, 4, 5]\n```\n"],
        ["reversed", "```\n<A> reversed(it: iterable<A>) -> list<A>\n```\n\nReturns a list of the elements in `it`, in reverse order.\n\n**Example**\n\n```\n>>> [1, 3, 5, 7] . reversed\n[7, 5, 3, 1]\n```\n"],
        ["permutations", "```\n<A> permutations(n: int, it: iterable<A>) -> list<vector<A>>\n```\n\nReturns a list of all permutations of `n` elements from `it`. If `n` is larger than the length of `it`, nothing will be returned. Raises an error if `n` is negative.\n\n**Example**\n\n```\n>>> [1, 2, 3] . permutations(2)\n[(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]\n```\n"],
        ["combinations", "```\n<A> combinations(n: int, it: iterable<A>) -> list<vector<A>>\n```\n\nReturns a list of all combinations of `n` elements from `it`. If `n` is larger than the length of `it`, nothing will be returned. Raises an error if `n` is negative.\n\n**Example**\n\n```\n>>> [1, 2, 3] . combinations(2)\n[(1, 2), (1, 3), (2, 3)]\n```\n"],
        ["pop", "```\n<A> pop(it: list<A> | set<A> | heap<A> | dict<A, ?>) -> A\n```\n\nPops a value from a collection. For `list`, this will be a value at the back of the collection. For a `heap`, this is the top of the heap, i.e. the minimum value.\n"],
        ["push", "```\n<A> push(x: A, it: list<A> | set<A> | heap<A>) -> iterable<A>\n```\n\nPushes a value `x` into a collection `it`. For `list`, this will be a value at the back of the collection.\n"],
        ["last", "```\n<A> last(it: list<A> | set<A>) -> A\n```\n\nReturns the last element of `it`.\n"],
        ["head", "```\n<A> head(it: list<A> | set<A> | heap<A>) -> A\n```\n\nReturns the first element (for `list`, the front, for `heap`, the top, i.e. the minimum) of `it`.\n"],
        ["init", "```\n<A> init(it: list<A> | set<A>) -> list<A>\n```\n\nReturns a list of all elements of `it` except the last.\n"],
        ["tail", "```\n<A> tail(it: list<A> | set<A>) -> list<A>\n```\n\nReturns a list of all elements of `it` except the first.\n"],
        ["abs", "```\nabs(x: int) -> int\n```\n\nReturns the absolute value of `x`.\n"],
        ["sqrt", "```\nsqrt(x: int) -> int\n```\n\nReturns the positive integer square root of `x`, or the largest `y` such that `y*y <= x`.\n"],
        ["lcm", "```\nlcm(...) -> int\n```\n\nPossible signatures:\n\n- `lcm(it: iterable<int>) -> int`\n- `lcm(int, ...) -> int`\n\nWith one argument, returns the least common multiple of each value in the iterable. With more than one argument, returns the least common multiple of all the arguments. Raises an error when invoked with no arguments.\n"],
        ["gcd", "```\ngcd(...) -> int\n```\n\nPossible signatures:\n\n- `gcd(it: iterable<int>) -> int`\n- `gcd(int, ...) -> int`\n\nWith one argument, returns the greatest common divisor of each value in the iterable. With more than one argument, returns the greatest common divisor of all the arguments. Raises an error when invoked with no arguments.\n"],
        ["split", "```\nsplit(delim: str, string: str) -> list<str>\n```\n\nSplits `string` on the delimiter `delim` and returns a `list` of all split elements.\n\n**Example**\n\n```\n>>> 'hello the world' . split(' ')\n['hello', 'the', 'world']\n```\n"],
        ["default", "```\n<K, V> default(x: V, it: dict<K, V>) -> dict<K, V>\n```\n\nSets the default value of `it` to `x`, and then returns `it`. This means that any future queries into `it` via the index syntax, if the key is not in the dictionary, will return `x`.\n\n**Note:** If `x` is a mutable value, such as a list, the same instance will be returned from each access to the default value.\n\n**Example**\n\n```\nlet d = dict()\nd['hello'] // will raise an error\nd . default('nope')\nd['hello'] // returns 'nope'\n```\n"],
        ["keys", "```\n<K, V> keys(it: dict<K, V>) -> set<K>\n```\n\nReturns a set of all keys in `it`, maintaining insertion order.\n"],
        ["values", "```\n<K, V> values(it: dict<K, V>) -> list<V>\n```\n\nReturns a list of all values in `it`, maintaining insertion order.\n"],
    ]);
}
